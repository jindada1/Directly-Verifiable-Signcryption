const MainBN = artifacts.require("MainBN");
const utils = require("../utils")
const bn128 = require("../curves/bn128")
const Signer = require("../signencrypt").Signer

const signer = new Signer(bn128);

contract('MainBN', (accounts) => {

    let Alice = bn128.keypair(utils.prikeys[0])
    let Bob = bn128.keypair(utils.prikeys[1])

    let M = utils.asciiToHex("Hello Bob")
    let r;
    let R;
    var ID_A;
    var ID_B;
    var w_A;
    var W_A;
    var w_B;
    var W_B;

    before(async () => {
        const mainbn = await MainBN.deployed();

        const Apubkey = await mainbn.drivePubkey(Alice.prikey);
        Alice.pubkey = Apubkey.map(utils.bnToHex)

        const Bpubkey = await mainbn.drivePubkey(Bob.prikey);
        Bob.pubkey = Bpubkey.map(utils.bnToHex)

        // mod bn128.order
        r = bn128.eccAddHex(utils.randomBytes(32), 0)
        const Rpubkey = await mainbn.drivePubkey(r);
        R = Rpubkey.map(utils.bnToHex)

        ID_A = Alice.pubkey[0]
        ID_B = Bob.pubkey[0]
        w_A = Alice.prikey;
        W_A = Alice.pubkey;
        w_B = Bob.prikey
        W_B = Bob.pubkey
    });


    it(`ECCMul`, async () => {

        const mainbn = await MainBN.deployed();

        let RSol = await mainbn.ECCMul(R, 10);
        RSol = RSol.map(utils.bnToHex)
        // console.log(RSol);

        // const RJS = bn128.mulPoint(R, 10);
        // console.log(RSol, RJS);

        // assert.deepEqual(RJS.map(BigInt), RSol.map(BigInt), 'ooops');
    });


    it(`ECCAdd`, async () => {

        const mainbn = await MainBN.deployed();

        let sumSol = await mainbn.ECCAdd(Alice.pubkey, Bob.pubkey);
        sumSol = sumSol.map(utils.bnToHex)
        // console.log(sumSol);

        // const sumJs = bn128.addPoints(Alice.pubkey, Bob.pubkey);
        // console.log(sumSol, sumJs);

        // assert.deepEqual(sumSol.map(BigInt), sumJs.map(BigInt), 'ooops');
    });


    it(`AliceK == BobK`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256[2] W_B  - Bob's public key
         * 
         * @return uint256[2] K
         */
        const AliceK_BN = await mainbn.AliceK(r, w_A, W_B);
        
        let AliceK = AliceK_BN.map(utils.bnToHex)

        /**
         * @param uint256[2] R    - signature
         * @param uint256[2] W_A  - Alice's public key
         * @param uint256    w_B  - Bob's private key
         * 
         * @return uint256[2] K
         */
        const BobK_BN = await mainbn.BobK(R, W_A, w_B);
        let BobK = BobK_BN.map(utils.bnToHex)

        // console.log({ AliceK, BobK });

        assert.deepEqual(AliceK.map(BigInt), BobK.map(BigInt));
    });


    it(`signCryption-sol & unSignCryption-sol`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         * 
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        const signature = await mainbn.signCryption(r, w_A, ID_A, M, W_B, ID_B);

        let R = signature.R.map(utils.bnToHex)
        let C = utils.bnToHex(signature.C)
        let s = utils.bnToHex(signature.s)
        // console.log({R, C, s});

        /**
         * @param uint256[2] R    - signature
         * @param uint256    C    - ciphertext
         * @param uint256    s    - signature
         * @param uint256[2] W_A  - Alice's public key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    w_B  - Bob's private key
         * @param uint256    ID_B - Bob's unique identifiers
         * 
         * @return uint256   M    - Decrypts the ciphertext C
         * @return bool      v    - result of verification(True/False).
         */
        const verification = await mainbn.unSignCryption(R, C, s, W_A, ID_A, w_B, ID_B);

        let M_sol = utils.bnToHex(verification.M)
        let v_sol = verification.v
        // console.log({ M, M_sol, v_sol });

        assert.equal(v_sol, true);
        assert.equal(M_sol, M);
    });


    it(`signCryption-sol & verifySignature-sol`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         * 
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        const signature = await mainbn.signCryption(r, w_A, ID_A, M, W_B, ID_B);

        let R = signature.R.map(utils.bnToHex)
        let C = utils.bnToHex(signature.C)
        let s = utils.bnToHex(signature.s)
        let st = utils.bnToHex(signature.t)
        // console.log({R, C, s, st});

        /**
         * @param R    - signature
         * @param C    - ciphertext
         * @param s    - signature
         * @param W_A  - Alice's public key
         * @param ID_A - Alice's unique identifiers
         * @param ID_B - Bob's unique identifiers
         * 
         * @return   v - result of verification (True/False).
         */
        const validation = await mainbn.verifySignature(R, C, s, W_A, ID_A, ID_B);
        let v = validation.v;
        let et = utils.bnToHex(validation.t);
        // console.log({ v, et });

        assert.equal(v, true);
    });
});