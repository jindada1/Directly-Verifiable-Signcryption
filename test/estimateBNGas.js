const MainBN = artifacts.require("MainBN");
const utils = require("../utils")
const bn128 = require("../curves/bn128")
const Signer = require("../signencrypt").Signer

const signer = new Signer(bn128);

contract('MainBN', (accounts) => {

    let Alice = bn128.keypair(utils.prikeys[0])
    let Bob = bn128.keypair(utils.prikeys[1])

    let M = utils.asciiToHex("Hello Bob")
    let r;
    let R;
    var ID_A;
    var ID_B;
    var w_A;
    var W_A;
    var w_B;
    var W_B;

    before(async () => {
        const mainbn = await MainBN.deployed();

        const Apubkey = await mainbn.drivePubkey(Alice.prikey);
        Alice.pubkey = Apubkey.map(utils.bnToHex)

        const Bpubkey = await mainbn.drivePubkey(Bob.prikey);
        Bob.pubkey = Bpubkey.map(utils.bnToHex)

        // mod bn128.order
        r = bn128.eccAddHex(utils.randomBytes(32), 0)
        const Rpubkey = await mainbn.drivePubkey(r);
        R = Rpubkey.map(utils.bnToHex)

        ID_A = Alice.pubkey[0]
        ID_B = Bob.pubkey[0]
        w_A = Alice.prikey;
        W_A = Alice.pubkey;
        w_B = Bob.prikey
        W_B = Bob.pubkey
    });


    it(`drivePubkey`, async () => {

        const mainbn = await MainBN.deployed();

        let gasUsed = await mainbn.drivePubkey.estimateGas(r);
        
        console.log(gasUsed);
    });


    it(`oneAndRightHalf`, async () => {

        const mainbn = await MainBN.deployed();

        let gasUsed = await mainbn.oneAndRightHalf.estimateGas(Bob.prikey);
        
        console.log(gasUsed);
    });


    it(`ECCMul`, async () => {

        const mainbn = await MainBN.deployed();

        let gasUsed = await mainbn.ECCMul.estimateGas(R, 10);
        
        console.log(gasUsed);
    });


    it(`ECCAdd`, async () => {

        const mainbn = await MainBN.deployed();

        let gasUsed = await mainbn.ECCAdd.estimateGas(Alice.pubkey, Bob.pubkey);
        
        console.log(gasUsed);
    });


    it(`AliceK`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256[2] W_B  - Bob's public key
         * 
         * @return uint256[2] K
         */
        const gasUsed = await mainbn.AliceK.estimateGas(r, w_A, W_B);
        
        console.log(gasUsed);
    });

    it(`BobK`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256[2] R    - signature
         * @param uint256[2] W_A  - Alice's public key
         * @param uint256    w_B  - Bob's private key
         * 
         * @return uint256[2] K
         */
        const gasUsed = await mainbn.BobK.estimateGas(R, W_A, w_B);
        
        console.log(gasUsed);
    });

    
    it(`signCryption-sol`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         * 
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        const gasUsed = await mainbn.signCryption.estimateGas(r, w_A, ID_A, M, W_B, ID_B);

        console.log(gasUsed);
    });


    it(`verifySignature-sol`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         * 
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        const signature = await mainbn.signCryption(r, w_A, ID_A, M, W_B, ID_B);

        let R = signature.R.map(utils.bnToHex)
        let C = utils.bnToHex(signature.C)
        let s = utils.bnToHex(signature.s)
        let st = utils.bnToHex(signature.t)
        // console.log({R, C, s, st});

        /**
         * @param R    - signature
         * @param C    - ciphertext
         * @param s    - signature
         * @param W_A  - Alice's public key
         * @param ID_A - Alice's unique identifiers
         * @param ID_B - Bob's unique identifiers
         * 
         * @return   v - result of verification (True/False).
         */
        const gasUsed = await mainbn.verifySignature.estimateGas(R, C, s, W_A, ID_A, ID_B);

        console.log(gasUsed);
    });


    it(`unSignCryption-sol`, async () => {

        const mainbn = await MainBN.deployed();

        /**
         * @param uint256    r    - random number generated by Alice
         * @param uint256    w_A  - Alice's private key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    M    - message to be signcrypted
         * @param uint256[2] W_B  - Bob's public key
         * @param uint256    ID_B - Bob's unique identifiers
         * 
         * @return uint256[2] R   - r * G, G is base of Elliptic Curve (Secp256k1)
         * @return uint256    C   - ciphertext of M
         * @return uint256    s   - signature
         */
        const signature = await mainbn.signCryption(r, w_A, ID_A, M, W_B, ID_B);

        let R = signature.R.map(utils.bnToHex)
        let C = utils.bnToHex(signature.C)
        let s = utils.bnToHex(signature.s)
        // console.log({R, C, s});

        /**
         * @param uint256[2] R    - signature
         * @param uint256    C    - ciphertext
         * @param uint256    s    - signature
         * @param uint256[2] W_A  - Alice's public key
         * @param uint256    ID_A - Alice's unique identifiers
         * @param uint256    w_B  - Bob's private key
         * @param uint256    ID_B - Bob's unique identifiers
         * 
         * @return uint256   M    - Decrypts the ciphertext C
         * @return bool      v    - result of verification(True/False).
         */
        const gasUsed = await mainbn.unSignCryption.estimateGas(R, C, s, W_A, ID_A, w_B, ID_B);

        console.log(gasUsed);
    });

    /*
        31932
            √ drivePubkey (230ms)

        22231
            √ oneAndRightHalf (191ms)

        33626
            √ ECCMul (212ms)

        29565
            √ ECCAdd (225ms)

        42404
            √ AliceK (285ms)

        45116
            √ BobK (280ms)

        53261
            √ signCryption-sol (301ms)

        47956
            √ verifySignature-sol (442ms)

        66542
            √ unSignCryption-sol (475ms)
    */
});