pragma solidity ^0.5.17;
pragma experimental ABIEncoderV2;

import "./Secp256k1.sol";

contract Main {
    uint256 public constant F = 0x0000000000000000000000000000000100000000000000000000000000000000;

    // 将一个 uint256 的前 127 位置 0，第 128 位置 1，剩下的 128 位保持不变
    function oneAndRightHalf(uint256 num) public pure returns (uint256) {
        return F + (num % F);
    }


    Secp256k1 public curve = new Secp256k1();

    /**
     * @dev signCryption
     * Alice generates the signcrypted text (R,C,s) to Bob.
     * @notice this function should be invoked by Alice
     * @param r    - random number generated by Alice
     * @param w_A  - Alice's private key
     * @param ID_A - Alice's unique identifiers
     * @param M    - message to be signcrypted
     * @param W_B  - Bob's public key
     * @param ID_B - Bob's unique identifiers
     * @return R   - r * G, G is base of Elliptic Curve (Secp256k1)
     * @return C   - ciphertext of M
     * @return s   - signature
     */
    function signCryption(
        uint256 r,
        uint256 w_A,
        uint256 ID_A,
        uint256 M,
        uint256[2] memory W_B,
        uint256 ID_B
    )
        public
        view
        returns (
            uint256[2] memory R,
            uint256 C,
            uint256 s
        )
    {
        // 计算该随机数 r 在椭圆曲线 G 上对应的公钥 R，写成坐标形式 (x_R, y_R)
        Secp256k1.G1Point memory point_R = pMul(curve.P1(), r);

        R = [point_R.X, point_R.Y];

        // 计算 x_RR
        uint256 x_RR = oneAndRightHalf(point_R.X);

        // 计算 K，坐标形式为（x_K, y_K）
        // Secp256k1.G1Point memory Point_W_B = Secp256k1.G1Point(W_B[0], W_B[1]);
        Secp256k1.G1Point memory point_K = pMul(point(W_B), r + x_RR * w_A);
        
        // 使用 keccak256 哈希函数计算密钥 k
        uint256 k = uint256(keccak256(abi.encodePacked(point_K.X, ID_A, point_K.Y, ID_B)));

        // 使用 k 对 M 进行加密，用 xor
        C = k ^ M;

        // 计算 t
        uint256 t = uint256(keccak256(abi.encodePacked(C, point_R.X, ID_A, point_R.Y, ID_B)));

        // 计算签名
        s = t * w_A - r;
    }

    /**
     * @dev unSignCryption
     * Bob verify signature (R,C,s) from Alice.
     * @notice this function should be invoked by Bob
     * @param R    - signature
     * @param C    - ciphertext
     * @param s    - signature
     * @param W_A  - Alice's public key
     * @param ID_A - Alice's unique identifiers
     * @param w_B  - Bob's private key
     * @param ID_B - Bob's unique identifiers
     * @return M   - Decrypts the ciphertext C
     * @return v   - result of verification(True/False).
     */
    function unSignCryption(
        uint256[2] memory R,
        uint256 C,
        uint256 s,
        uint256[2] memory W_A,
        uint256 ID_A,
        uint256 w_B,
        uint256 ID_B
    ) public view returns (uint256 M, bool v) {
        
        // 计算 x_RR
        uint256 x_RR = oneAndRightHalf(R[0]);

        // 计算 K，坐标形式为（x_K, y_K）
        Secp256k1.G1Point memory point_K = pMul(pAdd(point(R), pMul(point(W_A), x_RR)), w_B);

        // 使用 keccak256 哈希函数计算密钥 k
        uint256 k = uint256(keccak256(abi.encodePacked(point_K.X, ID_A, point_K.Y, ID_B)));

        // 使用 k 对 M 进行解密，用 xor
        M = k ^ C;

        // 计算 t
        uint256 t = uint256(keccak256(abi.encodePacked(C, R[0], ID_A, R[1], ID_B)));

        // 验证签名
        v = verify(R, W_A, t, s);
    }

    // 椭圆曲线上的加法
    function pAdd (
        Secp256k1.G1Point memory P1,
        Secp256k1.G1Point memory P2
    ) internal view returns(Secp256k1.G1Point memory) {
        return curve.g1add(P1, P2);
    }

    // 椭圆曲线上的乘法
    function pMul (
        Secp256k1.G1Point memory P,
        uint256 n
    ) internal view returns(Secp256k1.G1Point memory) {
        return curve.g1mul2(P, n);
    }
    
    // 将 uint256 数组转化成 Point 对象
    function point(
        uint256[2] memory P
    ) internal pure returns(Secp256k1.G1Point memory) {
        return Secp256k1.G1Point(P[0], P[1]);
    }

    // 验证签名
    function verify(
        uint256[2] memory R,
        uint256[2] memory W,
        uint256 t,
        uint256 s
    ) internal view returns (bool) {
        return pointEqual(
            pAdd(pMul(curve.P1(), s), point(R)), 
            pMul(point(W), t)
        );
    }

    // 判断两个曲线上的点是否相同
    function pointEqual(
        Secp256k1.G1Point memory p1,
        Secp256k1.G1Point memory p2
    ) internal pure returns (bool) {
        return p1.Y == p2.Y;
    }


    function drivePubkey(uint256 prikey)
        public
        view
        returns (uint256[2] memory)
    {
        Secp256k1.G1Point memory PK = pMul(curve.P1(), prikey);

        return [PK.X, PK.Y];
    }

    
    function reverseArray(uint256[2] memory pubkey)
        public
        pure
        returns (uint256[2] memory)
    {
        return [pubkey[1], pubkey[0]];
    }
}
