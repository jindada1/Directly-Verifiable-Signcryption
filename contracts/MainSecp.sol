pragma solidity ^0.5.17;
pragma experimental ABIEncoderV2;

import "./Secp256k1.sol";

contract MainSecp {
    
    uint256 constant public GEN_ORDER = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;
    
    /**
     * @dev AliceK
     * @notice this function should be invoked by Alice
     * @param r     - random number generated by Alice
     * @param w_A   - Alice's private key
     * @param W_B   - Bob's public key
     * @return K    - point K
     * @return x_RR - x_RR
     */
    function AliceK(
        uint256 r,
        uint256 w_A,
        uint256[2] memory W_B
    ) public view returns (uint256[2] memory K)
    {
        // 计算该随机数 r 在椭圆曲线 G 上对应的公钥 R，写成坐标形式 (x_R, y_R)
        Secp256k1.G1Point memory point_R = pMul(curve.P1(), r);

        // 计算 x_RR
        uint256 x_RR = oneAndRightHalf(point_R.X);

        // 计算 K，坐标形式为（x_K, y_K）
        uint256 X_RR_x_A = mulmod(x_RR, w_A, GEN_ORDER);
        Secp256k1.G1Point memory point_K = pMul(point(W_B), addmod(r, X_RR_x_A, GEN_ORDER));
        K = [point_K.X, point_K.Y];
    }


    /**
     * @dev signCryption
     * Alice generates the signcrypted text (R,C,s) to Bob.
     * @notice this function should be invoked by Alice
     * @param r    - random number generated by Alice
     * @param w_A  - Alice's private key
     * @param ID_A - Alice's unique identifiers
     * @param M    - message to be signcrypted
     * @param W_B  - Bob's public key
     * @param ID_B - Bob's unique identifiers
     * @return R   - r * G, G is base of Elliptic Curve (Secp256k1)
     * @return C   - ciphertext of M
     * @return s   - signature
     */
    function signCryption(
        uint256 r,
        uint256 w_A,
        uint256 ID_A,
        uint256 M,
        uint256[2] memory W_B,
        uint256 ID_B
    )
        public
        view
        returns (
            uint256[2] memory R,
            uint256 C,
            uint256 s
        )
    {
        // 计算该随机数 r 在椭圆曲线 G 上对应的公钥 R，写成坐标形式 (x_R, y_R)
        Secp256k1.G1Point memory point_R = pMul(curve.P1(), r);

        R = [point_R.X, point_R.Y];

        // // 计算 K，坐标形式为（x_K, y_K
        uint256[2] memory K = AliceK(r, w_A, W_B);
        
        // 使用 keccak256 哈希函数计算密钥 k
        uint256 k = uint256(keccak256(abi.encodePacked(K[0], ID_A, K[1], ID_B)));

        // 使用 k 对 M 进行加密，用 xor
        C = k ^ M;

        // 计算 t
        uint256 t = uint256(keccak256(abi.encodePacked(C, point_R.X, ID_A, point_R.Y, ID_B)));

        // 计算签名
        uint256 t_w_A = mulmod(t, w_A, GEN_ORDER);
        s = submod(t_w_A, r, GEN_ORDER);
    }
    
    /**
     * @dev BobK
     * @notice this function should be invoked by Bob
     * @param R     - signature's R
     * @param W_A   - Alice's public key
     * @param w_B   - Bob's private key
     * @return K    - point K
     * @return x_RR - x_RR
     */
    function BobK(
        uint256[2] memory R,
        uint256[2] memory W_A,
        uint256 w_B
    ) public view returns (uint256[2] memory K) {

        // 计算 x_RR
        uint256 x_RR = oneAndRightHalf(R[0]);

        // 计算 K，坐标形式为（x_K, y_K）
        Secp256k1.G1Point memory point_K = pMul(pAdd(point(R), pMul(point(W_A), x_RR)), w_B);
        K = [point_K.X, point_K.Y];
    }

    Secp256k1 public curve = new Secp256k1();

    /**
     * @dev unSignCryption
     * Bob verify signature and decrypt C (R,C,s) from Alice.
     * @notice this function should be invoked by Bob
     * @param R    - signature
     * @param C    - ciphertext
     * @param s    - signature
     * @param W_A  - Alice's public key
     * @param ID_A - Alice's unique identifiers
     * @param w_B  - Bob's private key
     * @param ID_B - Bob's unique identifiers
     * @return M   - Decrypts the ciphertext C
     * @return v   - result of verification(True/False).
     */
    function unSignCryption(
        uint256[2] memory R,
        uint256 C,
        uint256 s,
        uint256[2] memory W_A,
        uint256 ID_A,
        uint256 w_B,
        uint256 ID_B
    ) public view returns (uint256 M, bool v) {
        
        // 计算 x_RR
        uint256 x_RR = oneAndRightHalf(R[0]);

        // 计算 K，坐标形式为（x_K, y_K）
        Secp256k1.G1Point memory point_K = pMul(pAdd(point(R), pMul(point(W_A), x_RR)), w_B);

        // 使用 keccak256 哈希函数计算密钥 k
        uint256 k = uint256(keccak256(abi.encodePacked(point_K.X, ID_A, point_K.Y, ID_B)));

        // 使用 k 对 M 进行解密，用 xor
        M = k ^ C;

        // 验证签名
        v = verifySignature(R, C, s, W_A, ID_A, ID_B);
    }


    /**
     * @dev verifySignature
     * Bob verify signature (R,C,s) from Alice.
     * @notice this function should be invoked by Bob
     * @param R    - signature
     * @param C    - ciphertext
     * @param s    - signature
     * @param W_A  - Alice's public key
     * @param ID_A - Alice's unique identifiers
     * @param ID_B - Bob's unique identifiers
     * @return v   - result of verification(True/False).
     */
    function verifySignature(
        uint256[2] memory R,
        uint256 C,
        uint256 s,
        uint256[2] memory W_A,
        uint256 ID_A,
        uint256 ID_B
    ) public view returns (bool v) {

        // 计算 t
        uint256 t = uint256(keccak256(abi.encodePacked(C, R[0], ID_A, R[1], ID_B)));

        // 验证签名
        v = pointEqual(
            pAdd(pMul(curve.P1(), s), point(R)), 
            pMul(point(W_A), t)
        );
    }

    // 判断曲线上的两个点是否相等
    function pointEqual(
        Secp256k1.G1Point memory p1,
        Secp256k1.G1Point memory p2
    ) internal pure returns (bool) {
        return p1.Y == p2.Y;
    }


    uint256 public constant F = 0x0000000000000000000000000000000100000000000000000000000000000000;

    // 将一个 uint256 的前 127 位置 0，第 128 位置 1，剩下的 128 位保持不变
    function oneAndRightHalf(uint256 num) public pure returns (uint256) {
        return F + (num % F);
    }

    // 椭圆曲线上的加法
    function pAdd (
        Secp256k1.G1Point memory P1,
        Secp256k1.G1Point memory P2
    ) internal view returns(Secp256k1.G1Point memory) {
        return curve.g1add(P1, P2);
    }

    // 椭圆曲线上的乘法
    function pMul (
        Secp256k1.G1Point memory P,
        uint256 n
    ) internal view returns(Secp256k1.G1Point memory) {
        return curve.g1mul2(P, n);
    }
    
    // 将 uint256 数组转化成 Point 对象
    function point(
        uint256[2] memory P
    ) internal pure returns(Secp256k1.G1Point memory) {
        return Secp256k1.G1Point(P[0], P[1]);
    }


    function drivePubkey(uint256 prikey)
        public
        view
        returns (uint256[2] memory)
    {
        Secp256k1.G1Point memory PK = pMul(curve.P1(), prikey);
        return [PK.X, PK.Y];
    }


    function ECCMul(uint256[2] memory P, uint256 n)
        public
        view
        returns (uint256[2] memory R)
    {
        Secp256k1.G1Point memory Point_R = pMul(point(P), n);
        R = [Point_R.X, Point_R.Y];
    }


    function ECCAdd(uint256[2] memory P1, uint256[2] memory P2)
        public
        view
        returns (uint256[2] memory R)
    {
        Secp256k1.G1Point memory Point_R = pAdd(point(P1), point(P2));
        R = [Point_R.X, Point_R.Y];
    }

    function submod(uint x, uint y, uint m) public pure returns (uint){
        uint x_nn;

        if(x > y) {
            x_nn = x;
        } else {
            x_nn = x + GEN_ORDER;
        }

        return addmod(x_nn - y, 0, m);
    }
}
