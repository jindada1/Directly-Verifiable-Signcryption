const utils = require("./utils")


function AliceK(r, w_A, W_B) {
    
    const R = utils.drivePub(r);

    const x_RR = utils.oneAndRightHalf(R[0])

    const K = utils.mulPoint(W_B, utils.eccAddHex(r, utils.eccMulHex(x_RR, w_A)))

    return [x_RR, K]
}


function BobK(R, W_A, w_B) {

    const x_RR = utils.oneAndRightHalf(R[0])

    const K = utils.mulPoint(utils.addPoints(R, utils.mulPoint(W_A, x_RR)), w_B)

    return [x_RR, K]
}


/**
 * Public Verifiable Signcryption, invoked by Alice
 *
 * @method signCryption
 * @param {String}   r    - random number generated by Alice
 * @param {String}   w_A  - Alice's private key
 * @param {String}   ID_A - Alice's unique identifiers
 * @param {String}   M    - message to be signcrypted
 * @param {Array}    W_B  - Bob's public key
 * @param {String}   ID_B - Bob's unique identifiers
 * @returns {Array}  R    - r * G, G is base of Elliptic Curve (Secp256k1)
 * @returns {String} C    - ciphertext of M
 * @returns {String} s    - signature
 */
 function signCryption(r, w_A, ID_A, M, W_B, ID_B) {

    const R = utils.drivePub(r);

    const [x_RR, K] = AliceK(r, w_A, W_B)

    const k = utils.keccak256Hash([K[0], ID_A, K[1], ID_B])

    const C = utils.encrypt(M, k);
    
    const t = utils.keccak256Hash([C, R[0], ID_A, R[1], ID_B])

    const s = utils.eccSubHex(utils.eccMulHex(t, w_A), r)

    return {R, C, s}
}


module.exports = {
    AliceK,
    BobK,
    signCryption
};
