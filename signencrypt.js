const utils = require("./utils")

function Signer(curve) {

    function AliceK(r, w_A, W_B) {

        const R = curve.drivePub(r);

        const x_RR = utils.oneAndRightHalf(R[0])

        const K = curve.mulPoint(W_B, curve.eccAddHex(r, curve.eccMulHex(x_RR, w_A)))

        return [x_RR, K]
    }


    function BobK(R, W_A, w_B) {

        const x_RR = utils.oneAndRightHalf(R[0])

        const K = curve.mulPoint(curve.addPoints(R, curve.mulPoint(W_A, x_RR)), w_B)

        return [x_RR, K]
    }


    /**
     * Public Verifiable Signcryption, invoked by Alice
     *
     * @method signCryption
     * @param {String}   r    - random number generated by Alice
     * @param {String}   w_A  - Alice's private key
     * @param {String}   ID_A - Alice's unique identifiers
     * @param {String}   M    - message to be signcrypted
     * @param {Array}    W_B  - Bob's public key
     * @param {String}   ID_B - Bob's unique identifiers
     * @returns {Array}  R    - r * G, G is base of Elliptic Curve (Secp256k1)
     * @returns {String} C    - ciphertext of M
     * @returns {String} s    - signature
     */
    function signCryption(r, w_A, ID_A, M, W_B, ID_B) {

        const R = curve.drivePub(r);

        const [x_RR, K] = AliceK(r, w_A, W_B)

        const k = utils.keccak256Hash([K[0], ID_A, K[1], ID_B])

        const C = utils.encrypt(M, k);

        const t = utils.keccak256Hash([C, R[0], ID_A, R[1], ID_B])

        const s = curve.eccSubHex(curve.eccMulHex(t, w_A), r)

        return { R, C, s }
    }


    /**
     * Bob verify signature (R,C,s) from Alice.
     *
     * @method verifySignature
     * @param R    - signature
     * @param C    - ciphertext
     * @param s    - signature
     * @param W_A  - Alice's public key
     * @param ID_A - Alice's unique identifiers
     * @param ID_B - Bob's unique identifiers
     * @return v   - result of verification(True/False).
     */
    function verifySignature(R, C, s, W_A, ID_A, ID_B) {
        // 计算 t
        let t = utils.keccak256Hash([C, R[0], ID_A, R[1], ID_B]);
        // 验证签名
        const S = curve.drivePub(s);

        const S_R = curve.addPoints(S, R);
        const W_At = curve.mulPoint(W_A, t);

        return BigInt(S_R[1]) === BigInt(W_At[1])
    }

    return {
        AliceK,
        BobK,
        signCryption,
        verifySignature
    }
}

module.exports = {
    Signer
};
